// The graph function
// Given a colour and an input vertex:
// if colour is on an edge from the vertex, return the output vertex
// Otherwise return n 1's
def G[n:!N](col:!N, a:uint[n])lifted:!uint[n]{
  ones := vector(n, 1:!B) as !uint[n];
  return ones;
}

// Up to 3 colours: 0 (Red), 1 (Green), 2 (Blue)
// N = 6 - number of vertices
// 1 - Entrance, 6 - Exit
// Use n = 6 qubits
def G1[n:!N](col:!N, a:uint[n])lifted:uint[n]{
    // Entrance
    if (a == 1 && col == 0){
        return 2:uint[n];
    }
    if (a == 1 && col == 1){
        return 3:uint[n];
    }
    
    if (a == 2 && col == 0){
        return 1:uint[n];
    }
    if (a == 2 && col == 1){
        return 4:uint[n];
    }
    if (a == 2 && col == 2){
        return 5:uint[n];
    }
    
    if (a == 3 && col == 0){
        return 5:uint[n];
    }
    if (a == 3 && col == 1){
        return 1:uint[n];
    }
    if (a == 3 && col == 2){
        return 4:uint[n];
    }
    
    if (a == 4 && col == 0){
        return 6:uint[n];
    }
    if (a == 4 && col == 1){
        return 2:uint[n];
    }
    if (a == 4 && col == 2){
        return 3:uint[n];
    }
    
    if (a == 5 && col == 0){
        return 3:uint[n];
    }
    if (a == 5 && col == 1){
        return 6:uint[n];
    }
    if (a == 5 && col == 2){
        return 2:uint[n];
    }

    // Exit
    if (a == 6 && col == 0){
        return 4:uint[n];
    }
    if (a == 6 && col == 1){
        return 5:uint[n];
    }
    ones := vector(n, 1:!B) as uint[n];
    return ones;
}