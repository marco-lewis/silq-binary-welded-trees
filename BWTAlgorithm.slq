import BWTGraph1;
import BWTGraph2;
import ColourOracle;
import BWTGeneralGraph;
import SimT;
import utils;

numOfCols := 4;

// Simulation of q. walk hamiltonian at a time t
def Ham[n:!N](const G_or: !N × uint[n] ->lifted uint[n], t:!R, node_reg:uint[n]){
  neighbour_anc := 0:uint[n];
  err_anc := 0:B;

  for col in [0..numOfCols){
    print(col);
    // Perform first V_c oracle
    [neighbour_anc, err_anc] := V[n](G_or, col, node_reg, neighbour_anc, err_anc);

    // Simulation of T operation
    [node_reg, neighbour_anc, err_anc] := sim_T[n](t, node_reg, neighbour_anc, err_anc);

    // Perform second V_c oracle
    [neighbour_anc, err_anc] := V[n](G_or, col, node_reg, neighbour_anc, err_anc);
  }
  // UNSAFE
  forget(neighbour_anc=0:uint[n]);
  forget(err_anc=0:B);

  return node_reg;
}

def run[n:!N](const G_or: !N × uint[n] ->lifted uint[n], steps:!N, t:!R){
  // Start a in the Entrance state
  node_reg := 1:uint[n];
  for step in [0..steps){
    print(step);
    node_reg := Ham[n](G_or, t, node_reg);
  }
  dump();
  node_reg := measure(node_reg);
  return node_reg;
}

// Gets outputs much faster than Q#
// Also produces output w/ higher prob
def main(){
  // bits = 2 * ciel(log N) - where N is # of vertices
  t := 1/sqrt(2);

  // Graph 1
  // G := G1[6];
  G := λ(color:!N, const node:uint[6])qfree.{return BWTOracle[6, 2]([2,5,3,6] coerce !uint[6]^(2 ^ 2), color, node);};
  steps := 4;
  
  // Graph 2
  // G := G2[6];
  // G := λ(color:!N, const node:uint[6])qfree.{return BWTOracle[6, 3]([4,12,6,14,5,11,7,13] coerce !uint[6]^(2 ^ 3), color, node);};
  // steps := 6;
  
  
  results := vector(16, 0:!N);
  for i in [0..1){
    res:= run[6](G, steps, t);
    
    results[res] = results[res] + 1;
    print(res);
  }
  return results;
}