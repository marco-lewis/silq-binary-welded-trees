import ColourOracle;
import SimT;
import utils;

numOfCols := 4;

// Simulation of q. walk hamiltonian at a time t
def Ham[n:!N](const G_or: !N × uint[n] ->lifted uint[n], t:!R, node_reg:uint[n]){
  neighbour_anc := 0:uint[n];
  err_anc := 0:B;

  for col in [0..numOfCols){
    // Perform first V_c oracle
    [neighbour_anc, err_anc] := V[n](G_or, col, node_reg, neighbour_anc, err_anc);

    // Simulation of T operation
    [node_reg, neighbour_anc, err_anc] := sim_T[n](t, node_reg, neighbour_anc, err_anc);

    // Perform second V_c oracle
    [neighbour_anc, err_anc] := V[n](G_or, col, node_reg, neighbour_anc, err_anc);
  }
  // UNSAFE
  forget(neighbour_anc=0:uint[n]);
  forget(err_anc=0:B);

  return node_reg;
}

// Making calls to quantum walk a number of times
def BWT[n:!N](const G_or: !N × uint[n] ->lifted uint[n], steps:!N, t:!R, dumpState:!B){
  // Start a in the Entrance state
  node_reg := 1:uint[n];

  for step in [0..steps){
    print(step + 1);
    node_reg := Ham[n](G_or, t, node_reg);
  }

  if dumpState{
    dump();
  }

  node_reg := measure(node_reg);
  return node_reg;
}